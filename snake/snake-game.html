<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Game - Culebrita Cl√°sica</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Rajdhani', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0c29 0%, #302b63 25%, #24243e 50%, #302b63 75%, #0f0c29 100%);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      color: #fff;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(118, 75, 162, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    @keyframes gradientShift {

      0%,
      100% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }
    }

    .game-container {
      background: rgba(15, 15, 35, 0.85);
      backdrop-filter: blur(20px);
      border-radius: 30px;
      padding: 40px;
      box-shadow:
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 0 80px rgba(102, 126, 234, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 900px;
      width: 100%;
      border: 2px solid rgba(255, 255, 255, 0.1);
      position: relative;
      z-index: 1;
    }

    .game-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #667eea, #764ba2, #667eea);
      border-radius: 30px;
      z-index: -1;
      opacity: 0.3;
      animation: borderGlow 3s ease infinite;
    }

    @keyframes borderGlow {

      0%,
      100% {
        opacity: 0.3;
      }

      50% {
        opacity: 0.6;
      }
    }

    .game-header {
      text-align: center;
      margin-bottom: 30px;
      position: relative;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 3.5em;
      font-weight: 900;
      margin-bottom: 15px;
      background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
      letter-spacing: 3px;
      animation: titleGlow 2s ease-in-out infinite;
      text-transform: uppercase;
    }

    @keyframes titleGlow {

      0%,
      100% {
        filter: brightness(1);
      }

      50% {
        filter: brightness(1.3);
      }
    }

    .score-board {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .score-item {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%);
      padding: 20px;
      border-radius: 15px;
      font-size: 1.1em;
      font-weight: 600;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow:
        0 8px 20px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .score-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s;
    }

    .score-item:hover::before {
      left: 100%;
    }

    .score-item:hover {
      transform: translateY(-3px);
      box-shadow:
        0 12px 30px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 20px rgba(102, 126, 234, 0.3);
    }

    .score-item span {
      display: block;
      font-family: 'Orbitron', sans-serif;
      font-size: 2em;
      font-weight: 700;
      background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-top: 8px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    }

    .canvas-wrapper {
      display: flex;
      justify-content: center;
      margin-bottom: 25px;
      position: relative;
    }

    .canvas-wrapper::before {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 20px;
      z-index: -1;
      opacity: 0.3;
      filter: blur(20px);
      animation: canvasGlow 3s ease infinite;
    }

    @keyframes canvasGlow {

      0%,
      100% {
        opacity: 0.3;
        transform: scale(1);
      }

      50% {
        opacity: 0.5;
        transform: scale(1.02);
      }
    }

    #gameCanvas {
      border: 4px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0a0a1a 100%);
      box-shadow:
        0 10px 40px rgba(0, 0, 0, 0.6),
        0 0 60px rgba(102, 126, 234, 0.3),
        inset 0 0 100px rgba(0, 0, 0, 0.3);
      max-width: 100%;
      height: auto;
      position: relative;
      z-index: 1;
    }

    .controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 25px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .button-group {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    button {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.4) 0%, rgba(118, 75, 162, 0.4) 100%);
      border: 2px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      padding: 14px 28px;
      border-radius: 12px;
      font-size: 1.05em;
      font-weight: 600;
      font-family: 'Rajdhani', sans-serif;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow:
        0 4px 15px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    button:hover::before {
      width: 300px;
      height: 300px;
    }

    button:hover {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.6) 0%, rgba(118, 75, 162, 0.6) 100%);
      transform: translateY(-3px) scale(1.05);
      box-shadow:
        0 8px 25px rgba(0, 0, 0, 0.4),
        0 0 30px rgba(102, 126, 234, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
    }

    button:active {
      transform: translateY(-1px) scale(1.02);
    }

    button.active {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.6) 0%, rgba(255, 237, 78, 0.6) 100%);
      border-color: #ffd700;
      box-shadow:
        0 8px 25px rgba(255, 215, 0, 0.4),
        0 0 30px rgba(255, 215, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    button span {
      position: relative;
      z-index: 1;
    }

    .mobile-controls {
      display: none;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 20px;
    }

    .mobile-controls button {
      padding: 20px;
      font-size: 1.5em;
      aspect-ratio: 1;
    }

    .mobile-controls button.arrow-up {
      grid-column: 2;
    }

    .mobile-controls button.arrow-left {
      grid-column: 1;
    }

    .mobile-controls button.arrow-right {
      grid-column: 3;
    }

    .mobile-controls button.arrow-down {
      grid-column: 2;
    }

    .settings-panel {
      background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
      display: none;
      border: 2px solid rgba(255, 255, 255, 0.1);
      box-shadow:
        0 10px 30px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }

    .settings-panel.active {
      display: block;
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .settings-panel h3 {
      font-family: 'Orbitron', sans-serif;
      margin-bottom: 20px;
      background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-size: 1.8em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .setting-item {
      margin-bottom: 20px;
    }

    .setting-item label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      font-size: 1.1em;
      color: rgba(255, 255, 255, 0.9);
    }

    .setting-item input,
    .setting-item select {
      width: 100%;
      padding: 12px 15px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background: rgba(15, 15, 35, 0.6);
      color: #fff;
      font-size: 1em;
      font-family: 'Rajdhani', sans-serif;
      transition: all 0.3s ease;
    }

    .setting-item input:focus,
    .setting-item select:focus {
      outline: none;
      border-color: rgba(102, 126, 234, 0.6);
      background: rgba(20, 20, 40, 0.8);
      box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
    }

    .setting-item input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .game-over.active {
      display: flex;
    }

    .game-over-content {
      background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
      padding: 50px;
      border-radius: 25px;
      text-align: center;
      max-width: 450px;
      width: 90%;
      border: 3px solid rgba(255, 215, 0, 0.3);
      box-shadow:
        0 20px 60px rgba(0, 0, 0, 0.6),
        0 0 80px rgba(255, 215, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(20px);
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px) scale(0.9);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .game-over-content h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 3em;
      margin-bottom: 25px;
      background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    }

    .game-over-content p {
      font-size: 1.5em;
      margin-bottom: 20px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.9);
    }

    .game-over-content span {
      color: #ffd700;
      font-weight: 700;
      font-size: 1.2em;
    }

    .compression-warning {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(255, 0, 0, 0.9) 0%, rgba(200, 0, 0, 0.9) 100%);
      color: #fff;
      padding: 18px 35px;
      border-radius: 15px;
      font-size: 1.3em;
      font-weight: 700;
      font-family: 'Rajdhani', sans-serif;
      display: none;
      z-index: 999;
      border: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow:
        0 10px 30px rgba(255, 0, 0, 0.5),
        0 0 40px rgba(255, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      text-transform: uppercase;
      letter-spacing: 2px;
      animation: compressionPulse 0.8s infinite;
    }

    .compression-warning.active {
      display: block;
    }

    @keyframes compressionPulse {

      0%,
      100% {
        transform: translateX(-50%) scale(1);
        box-shadow:
          0 10px 30px rgba(255, 0, 0, 0.5),
          0 0 40px rgba(255, 0, 0, 0.4);
      }

      50% {
        transform: translateX(-50%) scale(1.08);
        box-shadow:
          0 15px 40px rgba(255, 0, 0, 0.7),
          0 0 60px rgba(255, 0, 0, 0.6);
      }
    }

    .enemy-warning {
      position: fixed;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(255, 165, 0, 0.9) 0%, rgba(255, 140, 0, 0.9) 100%);
      color: #fff;
      padding: 15px 30px;
      border-radius: 12px;
      font-size: 1.1em;
      font-weight: 700;
      font-family: 'Rajdhani', sans-serif;
      display: none;
      z-index: 999;
      border: 2px solid rgba(255, 215, 0, 0.4);
      box-shadow:
        0 8px 25px rgba(255, 165, 0, 0.5),
        0 0 35px rgba(255, 165, 0, 0.3);
      backdrop-filter: blur(10px);
      text-transform: uppercase;
      letter-spacing: 1px;
      animation: enemyWarningPulse 1.2s infinite;
    }

    .enemy-warning.active {
      display: block;
    }

    @keyframes enemyWarningPulse {

      0%,
      100% {
        transform: translateX(-50%) scale(1);
        box-shadow:
          0 8px 25px rgba(255, 165, 0, 0.5),
          0 0 35px rgba(255, 165, 0, 0.3);
      }

      50% {
        transform: translateX(-50%) scale(1.05);
        box-shadow:
          0 12px 35px rgba(255, 165, 0, 0.7),
          0 0 50px rgba(255, 165, 0, 0.5);
      }
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2em;
      }

      .game-container {
        padding: 15px;
      }

      .score-item {
        font-size: 1em;
        padding: 10px 15px;
        min-width: 100px;
      }

      .score-item span {
        font-size: 1.3em;
      }

      .mobile-controls {
        display: grid;
      }

      .controls {
        flex-direction: column;
      }

      .button-group {
        width: 100%;
        justify-content: center;
      }

      button {
        flex: 1;
        min-width: 100px;
      }
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 1.5em;
      }

      .score-board {
        flex-direction: column;
      }

      .score-item {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div class="game-container">
    <div class="game-header">
      <h1>üêç Snake Game</h1>
    </div>

    <div class="score-board">
      <div class="score-item">
        Puntaje: <span id="score">0</span>
      </div>
      <div class="score-item">
        Longitud: <span id="length">1</span>
      </div>
      <div class="score-item">
        Modo: <span id="mode-display">Cl√°sico</span>
      </div>
    </div>

    <div class="canvas-wrapper">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div class="compression-warning" id="compressionWarning">
      ‚ö†Ô∏è ¬°COMPRESI√ìN! Mueve r√°pido o perder√°s
    </div>

    <div class="enemy-warning" id="enemyWarning">
      ‚ö†Ô∏è ¬°Enemigo activo! Cons√∫melo r√°pido
    </div>

    <div class="controls">
      <div class="button-group">
        <button id="startBtn"><span>‚ñ∂Ô∏è Iniciar</span></button>
        <button id="pauseBtn"><span>‚è∏Ô∏è Pausar</span></button>
        <button id="resetBtn"><span>üîÑ Reiniciar</span></button>
      </div>
      <div class="button-group">
        <button id="settingsBtn"><span>‚öôÔ∏è Configuraci√≥n</span></button>
      </div>
    </div>

    <div class="mobile-controls">
      <button class="arrow-up" onclick="changeDirection('up')">‚ñ≤</button>
      <button class="arrow-left" onclick="changeDirection('left')">‚óÑ</button>
      <button class="arrow-right" onclick="changeDirection('right')">‚ñ∫</button>
      <button class="arrow-down" onclick="changeDirection('down')">‚ñº</button>
    </div>

    <div class="settings-panel" id="settingsPanel">
      <h3>‚öôÔ∏è Configuraci√≥n</h3>

      <div class="setting-item">
        <label>Modo de Juego:</label>
        <select id="gameMode">
          <option value="classic">Cl√°sico</option>
          <option value="walls">Muros</option>
          <option value="enemy">Enemigo</option>
          <option value="compression">Compresi√≥n</option>
        </select>
      </div>

      <div class="setting-item">
        <label>Velocidad:</label>
        <select id="gameSpeed">
          <option value="slow">Lenta</option>
          <option value="medium" selected>Media</option>
          <option value="fast">R√°pida</option>
          <option value="extreme">Extrema</option>
        </select>
      </div>

      <div class="setting-item">
        <label>Audio de Fondo - Subir archivo:</label>
        <input type="file" id="audioFile" accept="audio/*">
      </div>

      <div class="setting-item">
        <label>Audio de Fondo - URL:</label>
        <input type="url" id="audioUrl" placeholder="https://ejemplo.com/audio.mp3">
      </div>

      <div class="setting-item">
        <button onclick="applyAudio()"><span>üîä Aplicar Audio</span></button>
        <button onclick="stopAudio()"><span>üîá Detener Audio</span></button>
        <button onclick="toggleSettings()"><span>Cerrar</span></button>
      </div>
    </div>
  </div>

  <div class="game-over" id="gameOver">
    <div class="game-over-content">
      <h2>Game Over</h2>
      <p>Puntaje Final: <span id="finalScore">0</span></p>
      <p>Longitud Final: <span id="finalLength">0</span></p>
      <button onclick="resetGame()"><span>üîÑ Jugar de Nuevo</span></button>
    </div>
  </div>

  <script>
    // Configuraci√≥n del canvas
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 20;
    let canvasSize = Math.min(window.innerWidth - 60, 600);
    canvasSize = Math.floor(canvasSize / gridSize) * gridSize;
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const tileCount = canvasSize / gridSize;

    // Variables del juego
    let snake = [{ x: 10, y: 10 }];
    let direction = { x: 1, y: 0 };
    let nextDirection = { x: 1, y: 0 };
    let food = { x: 15, y: 15 };
    let score = 0;
    let gameRunning = false;
    let gamePaused = false;
    let gameMode = 'classic';
    let gameSpeed = 100;
    let audio = null;

    // Modos especiales
    let walls = [];
    let wallTimer = 0;
    let enemy = null;
    let enemyTimer = 0;
    let enemyActive = false;
    let compressionMode = false;
    let compressionTimer = 0;
    let compressionSpeed = 0.5;

    // Previsualizaci√≥n de elementos
    let upcomingWall = null;
    let upcomingWallTimer = 0;
    let upcomingEnemy = null;
    let upcomingEnemyTimer = 0;

    // Event listeners
    document.addEventListener('keydown', handleKeyPress);
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('resetBtn').addEventListener('click', resetGame);
    document.getElementById('settingsBtn').addEventListener('click', toggleSettings);
    document.getElementById('gameMode').addEventListener('change', (e) => {
      gameMode = e.target.value;
      updateModeDisplay();
    });
    document.getElementById('gameSpeed').addEventListener('change', (e) => {
      const speeds = { slow: 150, medium: 100, fast: 70, extreme: 40 };
      gameSpeed = speeds[e.target.value];
    });

    // Redimensionar canvas en respuesta a cambios de ventana
    window.addEventListener('resize', () => {
      let newSize = Math.min(window.innerWidth - 60, 600);
      newSize = Math.floor(newSize / gridSize) * gridSize;
      canvas.width = newSize;
      canvas.height = newSize;
    });

    function updateModeDisplay () {
      const modeNames = {
        classic: 'Cl√°sico',
        walls: 'Muros',
        enemy: 'Enemigo',
        compression: 'Compresi√≥n'
      };
      document.getElementById('mode-display').textContent = modeNames[gameMode] || 'Cl√°sico';
    }

    function toggleSettings () {
      const panel = document.getElementById('settingsPanel');
      panel.classList.toggle('active');
    }

    function applyAudio () {
      stopAudio();
      const fileInput = document.getElementById('audioFile');
      const urlInput = document.getElementById('audioUrl');

      if (fileInput.files && fileInput.files[0]) {
        const file = fileInput.files[0];
        const url = URL.createObjectURL(file);
        audio = new Audio(url);
        audio.loop = true;
        audio.volume = 0.3;
        audio.play().catch(e => console.log('Error reproduciendo audio:', e));
      } else if (urlInput.value) {
        audio = new Audio(urlInput.value);
        audio.loop = true;
        audio.volume = 0.3;
        audio.play().catch(e => console.log('Error reproduciendo audio:', e));
      }
    }

    function stopAudio () {
      if (audio) {
        audio.pause();
        audio = null;
      }
    }

    function changeDirection (newDir) {
      if (!gameRunning || gamePaused) return;

      const dirs = {
        'up': { x: 0, y: -1 },
        'down': { x: 0, y: 1 },
        'left': { x: -1, y: 0 },
        'right': { x: 1, y: 0 }
      };

      if (dirs[newDir]) {
        // Prevenir movimiento opuesto
        if (direction.x !== -dirs[newDir].x || direction.y !== -dirs[newDir].y) {
          nextDirection = dirs[newDir];
        }
      }
    }

    function handleKeyPress (e) {
      if (!gameRunning || gamePaused) return;

      const keyDirs = {
        'ArrowUp': { x: 0, y: -1 },
        'ArrowDown': { x: 0, y: 1 },
        'ArrowLeft': { x: -1, y: 0 },
        'ArrowRight': { x: 1, y: 0 }
      };

      if (keyDirs[e.key]) {
        // Prevenir movimiento opuesto
        if (direction.x !== -keyDirs[e.key].x || direction.y !== -keyDirs[e.key].y) {
          nextDirection = keyDirs[e.key];
        }
        e.preventDefault();
      }
    }

    function startGame () {
      if (gameRunning) return;
      gameRunning = true;
      gamePaused = false;
      resetGameState();
      gameLoop();
    }

    function togglePause () {
      if (!gameRunning) return;
      gamePaused = !gamePaused;
      if (!gamePaused) {
        gameLoop();
      }
    }

    function resetGame () {
      gameRunning = false;
      gamePaused = false;
      resetGameState();
      document.getElementById('gameOver').classList.remove('active');
      draw();
    }

    function resetGameState () {
      snake = [{ x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }];
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      score = 0;
      walls = [];
      wallTimer = 0;
      enemy = null;
      enemyTimer = 0;
      enemyActive = false;
      compressionMode = false;
      compressionTimer = 0;
      upcomingWall = null;
      upcomingWallTimer = 0;
      upcomingEnemy = null;
      upcomingEnemyTimer = 0;
      spawnFood();
      updateScore();
      document.getElementById('compressionWarning').classList.remove('active');
      document.getElementById('enemyWarning').classList.remove('active');
    }

    function spawnFood () {
      let validPosition = false;
      let attempts = 0;
      while (!validPosition && attempts < 100) {
        food = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount)
        };
        validPosition = true;

        // Verificar que no est√© en la serpiente
        for (let segment of snake) {
          if (segment.x === food.x && segment.y === food.y) {
            validPosition = false;
            break;
          }
        }

        // Verificar que no est√© en un muro
        for (let wall of walls) {
          if (wall.x === food.x && wall.y === food.y) {
            validPosition = false;
            break;
          }
        }

        attempts++;
      }
    }

    function spawnEnemy () {
      if (gameMode !== 'enemy') return;

      // Si ya hay un enemigo activo, no crear otro
      if (enemyActive) return;

      let validPosition = false;
      let attempts = 0;
      while (!validPosition && attempts < 100) {
        upcomingEnemy = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount)
        };
        validPosition = true;

        // Verificar que no est√© en la serpiente
        for (let segment of snake) {
          if (segment.x === upcomingEnemy.x && segment.y === upcomingEnemy.y) {
            validPosition = false;
            break;
          }
        }

        // Verificar que no est√© en la comida
        if (food.x === upcomingEnemy.x && food.y === upcomingEnemy.y) {
          validPosition = false;
        }

        // Verificar que no est√© en un muro
        for (let wall of walls) {
          if (wall.x === upcomingEnemy.x && wall.y === upcomingEnemy.y) {
            validPosition = false;
            break;
          }
        }

        attempts++;
      }

      if (validPosition) {
        upcomingEnemyTimer = 60; // Previsualizaci√≥n por 60 frames
      }
    }

    function spawnWall () {
      if (gameMode !== 'walls') return;

      // Si ya hay un muro en previsualizaci√≥n, no crear otro
      if (upcomingWall) return;

      let validPosition = false;
      let attempts = 0;
      while (!validPosition && attempts < 50) {
        upcomingWall = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount)
        };
        validPosition = true;

        // Verificar que no est√© en la serpiente
        for (let segment of snake) {
          if (segment.x === upcomingWall.x && segment.y === upcomingWall.y) {
            validPosition = false;
            break;
          }
        }

        // Verificar que no est√© en la comida o enemigo
        if (food.x === upcomingWall.x && food.y === upcomingWall.y) {
          validPosition = false;
        }
        if (enemy && enemy.x === upcomingWall.x && enemy.y === upcomingWall.y) {
          validPosition = false;
        }

        // Verificar que no se superponga con otros muros
        for (let existingWall of walls) {
          if (existingWall.x === upcomingWall.x && existingWall.y === upcomingWall.y) {
            validPosition = false;
            break;
          }
        }

        attempts++;
      }

      if (validPosition) {
        upcomingWallTimer = 60; // Previsualizaci√≥n por 60 frames
      } else {
        upcomingWall = null;
      }
    }

    function update () {
      if (!gameRunning || gamePaused) return;

      direction = { ...nextDirection };

      // Actualizar posici√≥n de la cabeza
      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
      };

      // Verificar colisiones con muros
      for (let wall of walls) {
        if (head.x === wall.x && head.y === wall.y) {
          handleCollision();
          return;
        }
      }

      // Verificar colisi√≥n con bordes
      if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
        handleCollision();
        return;
      }

      // Verificar colisi√≥n consigo misma
      for (let segment of snake) {
        if (head.x === segment.x && head.y === segment.y) {
          handleCollision();
          return;
        }
      }

      // Modo compresi√≥n: si hay colisi√≥n, activar compresi√≥n
      if (compressionMode && compressionTimer > 0) {
        compressionTimer--;
        if (compressionTimer % 10 === 0 && snake.length > 1) {
          snake.pop(); // Eliminar un segmento cada 10 frames
        }
        if (compressionTimer <= 0) {
          gameOver();
          return;
        }
      } else {
        compressionMode = false;
        document.getElementById('compressionWarning').classList.remove('active');
      }

      snake.unshift(head);

      // Verificar si comi√≥ la comida
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        updateScore();
        spawnFood();
      } else {
        snake.pop();
      }

      // Verificar si comi√≥ el enemigo
      if (enemy && enemyActive && head.x === enemy.x && head.y === enemy.y) {
        score += 50;
        updateScore();
        enemy = null;
        enemyActive = false;
        enemyTimer = 0;
        document.getElementById('enemyWarning').classList.remove('active');
      } else if (enemy && enemyActive) {
        enemyTimer--;
        if (enemyTimer <= 0) {
          // El enemigo ataca: reducir serpiente
          const segmentsToRemove = Math.max(1, Math.floor(snake.length * 0.2));
          for (let i = 0; i < segmentsToRemove && snake.length > 1; i++) {
            snake.pop();
          }
          enemy = null;
          enemyActive = false;
          document.getElementById('enemyWarning').classList.remove('active');
          updateScore();
        }
      }

      // Actualizar previsualizaci√≥n de muros
      if (upcomingWall) {
        upcomingWallTimer--;
        if (upcomingWallTimer <= 0) {
          walls.push(upcomingWall);
          upcomingWall = null;
          upcomingWallTimer = 0;
        }
      }

      // Actualizar previsualizaci√≥n de enemigos
      if (upcomingEnemy) {
        upcomingEnemyTimer--;
        if (upcomingEnemyTimer <= 0) {
          enemy = upcomingEnemy;
          enemyTimer = 300;
          enemyActive = true;
          upcomingEnemy = null;
          upcomingEnemyTimer = 0;
          document.getElementById('enemyWarning').classList.add('active');
        }
      }

      // Actualizar modos especiales
      if (gameMode === 'walls') {
        wallTimer++;
        if (wallTimer >= 150 && !upcomingWall) { // Cada 150 frames
          spawnWall();
          wallTimer = 0;
        }
      }

      if (gameMode === 'enemy' && !enemyActive && !upcomingEnemy && Math.random() < 0.01) {
        spawnEnemy();
      }

      updateScore();
    }

    function handleCollision () {
      if (gameMode === 'compression') {
        compressionMode = true;
        compressionTimer = 300; // 300 frames para resolver
        document.getElementById('compressionWarning').classList.add('active');
        // Mover la cabeza fuera del borde/obst√°culo
        const head = snake[0];
        if (head.x < 0) head.x = 0;
        if (head.x >= tileCount) head.x = tileCount - 1;
        if (head.y < 0) head.y = 0;
        if (head.y >= tileCount) head.y = tileCount - 1;
      } else {
        gameOver();
      }
    }

    function gameOver () {
      gameRunning = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalLength').textContent = snake.length;
      document.getElementById('gameOver').classList.add('active');
      stopAudio();
    }

    function updateScore () {
      document.getElementById('score').textContent = score;
      document.getElementById('length').textContent = snake.length;
    }

    function draw () {
      // Limpiar canvas con gradiente
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#0a0a1a');
      gradient.addColorStop(0.5, '#1a1a2e');
      gradient.addColorStop(1, '#0a0a1a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Dibujar grid con efecto sutil
      ctx.strokeStyle = 'rgba(102, 126, 234, 0.08)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= tileCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
      }

      // Dibujar previsualizaci√≥n de muro (color marr√≥n/rojizo pulsante)
      if (upcomingWall) {
        const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
        const x = upcomingWall.x * gridSize;
        const y = upcomingWall.y * gridSize;

        // Sombra
        ctx.fillStyle = `rgba(139, 69, 19, ${0.3 * pulse})`;
        ctx.fillRect(x + 2, y + 2, gridSize - 4, gridSize - 4);

        // Borde brillante
        ctx.strokeStyle = `rgba(205, 133, 63, ${0.8 * pulse})`;
        ctx.lineWidth = 3;
        ctx.strokeRect(x + 2, y + 2, gridSize - 4, gridSize - 4);

        // Centro
        ctx.fillStyle = `rgba(139, 69, 19, ${0.6 * pulse})`;
        ctx.fillRect(x + 4, y + 4, gridSize - 8, gridSize - 8);

        // Efecto de brillo
        const glowGradient = ctx.createRadialGradient(
          x + gridSize / 2, y + gridSize / 2, 0,
          x + gridSize / 2, y + gridSize / 2, gridSize / 2
        );
        glowGradient.addColorStop(0, `rgba(255, 140, 0, ${0.4 * pulse})`);
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.fillRect(x, y, gridSize, gridSize);
      }

      // Dibujar muros con textura mejorada
      for (let wall of walls) {
        const x = wall.x * gridSize;
        const y = wall.y * gridSize;

        // Sombra
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(x + 3, y + 3, gridSize - 6, gridSize - 6);

        // Cuerpo del muro con gradiente
        const wallGradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize);
        wallGradient.addColorStop(0, '#8b4513');
        wallGradient.addColorStop(0.5, '#a0522d');
        wallGradient.addColorStop(1, '#654321');
        ctx.fillStyle = wallGradient;
        ctx.fillRect(x + 1, y + 1, gridSize - 2, gridSize - 2);

        // Brillo superior
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(x + 1, y + 1, gridSize - 2, 3);

        // Borde
        ctx.strokeStyle = '#5a3a1a';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 1, y + 1, gridSize - 2, gridSize - 2);
      }

      // Dibujar previsualizaci√≥n de enemigo (color naranja/amarillo pulsante)
      if (upcomingEnemy) {
        const pulse = Math.sin(Date.now() / 80) * 0.4 + 0.6;
        const x = upcomingEnemy.x * gridSize + gridSize / 2;
        const y = upcomingEnemy.y * gridSize + gridSize / 2;
        const radius = gridSize / 2 - 2;

        // Brillo exterior
        const enemyGlow = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
        enemyGlow.addColorStop(0, `rgba(255, 165, 0, ${0.6 * pulse})`);
        enemyGlow.addColorStop(0.5, `rgba(255, 215, 0, ${0.3 * pulse})`);
        enemyGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = enemyGlow;
        ctx.beginPath();
        ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
        ctx.fill();

        // C√≠rculo principal
        const enemyGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        enemyGradient.addColorStop(0, `rgba(255, 215, 0, ${pulse})`);
        enemyGradient.addColorStop(0.7, `rgba(255, 165, 0, ${0.8 * pulse})`);
        enemyGradient.addColorStop(1, `rgba(255, 140, 0, ${0.6 * pulse})`);
        ctx.fillStyle = enemyGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Borde pulsante
        ctx.strokeStyle = `rgba(255, 215, 0, ${0.9 * pulse})`;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Indicador de advertencia
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('!', x, y + 4);
      }

      // Dibujar comida con efecto mejorado
      const foodX = food.x * gridSize + gridSize / 2;
      const foodY = food.y * gridSize + gridSize / 2;
      const foodRadius = gridSize / 2 - 2;
      const foodPulse = Math.sin(Date.now() / 150) * 0.2 + 1;

      // Brillo exterior
      const foodGlow = ctx.createRadialGradient(foodX, foodY, 0, foodX, foodY, foodRadius * 2);
      foodGlow.addColorStop(0, 'rgba(255, 71, 87, 0.6)');
      foodGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = foodGlow;
      ctx.beginPath();
      ctx.arc(foodX, foodY, foodRadius * 2 * foodPulse, 0, Math.PI * 2);
      ctx.fill();

      // Gradiente de la comida
      const foodGradient = ctx.createRadialGradient(
        foodX - 3, foodY - 3, 0,
        foodX, foodY, foodRadius
      );
      foodGradient.addColorStop(0, '#ffed4e');
      foodGradient.addColorStop(0.5, '#ff4757');
      foodGradient.addColorStop(1, '#c92a2a');
      ctx.fillStyle = foodGradient;
      ctx.beginPath();
      ctx.arc(foodX, foodY, foodRadius * foodPulse, 0, Math.PI * 2);
      ctx.fill();

      // Brillo superior
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(foodX - 3, foodY - 3, foodRadius * 0.4 * foodPulse, 0, Math.PI * 2);
      ctx.fill();

      // Dibujar enemigo activo mejorado
      if (enemy && enemyActive) {
        const enemyX = enemy.x * gridSize + gridSize / 2;
        const enemyY = enemy.y * gridSize + gridSize / 2;
        const enemyRadius = gridSize / 2 - 2;
        const alpha = Math.min(1, enemyTimer / 100);
        const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;

        // Brillo exterior pulsante
        const activeEnemyGlow = ctx.createRadialGradient(
          enemyX, enemyY, 0,
          enemyX, enemyY, enemyRadius * 2.5
        );
        activeEnemyGlow.addColorStop(0, `rgba(255, 165, 0, ${0.8 * alpha * pulse})`);
        activeEnemyGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = activeEnemyGlow;
        ctx.beginPath();
        ctx.arc(enemyX, enemyY, enemyRadius * 2.5, 0, Math.PI * 2);
        ctx.fill();

        // C√≠rculo principal
        const activeEnemyGradient = ctx.createRadialGradient(
          enemyX, enemyY, 0,
          enemyX, enemyY, enemyRadius
        );
        activeEnemyGradient.addColorStop(0, `rgba(255, 215, 0, ${alpha})`);
        activeEnemyGradient.addColorStop(0.7, `rgba(255, 165, 0, ${0.9 * alpha})`);
        activeEnemyGradient.addColorStop(1, `rgba(255, 140, 0, ${0.7 * alpha})`);
        ctx.fillStyle = activeEnemyGradient;
        ctx.beginPath();
        ctx.arc(enemyX, enemyY, enemyRadius, 0, Math.PI * 2);
        ctx.fill();

        // Borde pulsante
        ctx.strokeStyle = `rgba(255, 215, 0, ${alpha * pulse})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Indicador de tiempo
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        const timeLeft = Math.ceil(enemyTimer / 10);
        ctx.fillText(timeLeft.toString(), enemyX, enemyY + 4);
      }

      // Dibujar serpiente mejorada
      snake.forEach((segment, index) => {
        const x = segment.x * gridSize;
        const y = segment.y * gridSize;
        const size = gridSize - 2;

        if (index === 0) {
          // Cabeza con efecto 3D
          const headGradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize);
          if (compressionMode) {
            headGradient.addColorStop(0, '#ff8787');
            headGradient.addColorStop(0.5, '#ff6b6b');
            headGradient.addColorStop(1, '#fa5252');
          } else {
            headGradient.addColorStop(0, '#51cf66');
            headGradient.addColorStop(0.5, '#2ed573');
            headGradient.addColorStop(1, '#20bf6b');
          }

          // Sombra de la cabeza
          ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
          ctx.fillRect(x + 3, y + 3, size, size);

          // Cabeza con gradiente
          ctx.fillStyle = headGradient;
          ctx.fillRect(x + 1, y + 1, size, size);

          // Brillo superior
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.fillRect(x + 1, y + 1, size, size / 3);

          // Borde destacado
          ctx.strokeStyle = compressionMode ? 'rgba(255, 107, 107, 0.8)' : 'rgba(46, 213, 115, 0.8)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x + 1, y + 1, size, size);

          // Ojos mejorados
          ctx.fillStyle = '#fff';
          const eyeSize = 4;
          const eyeOffset = 5;
          const pupilSize = 2;

          if (direction.x === 1) { // Derecha
            // Ojo derecho
            ctx.fillRect(x + eyeOffset + 7, y + eyeOffset, eyeSize, eyeSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + eyeOffset + 8, y + eyeOffset + 1, pupilSize, pupilSize);

            // Ojo izquierdo
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + eyeOffset + 7, y + eyeOffset + 9, eyeSize, eyeSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + eyeOffset + 8, y + eyeOffset + 10, pupilSize, pupilSize);
          } else if (direction.x === -1) { // Izquierda
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + eyeOffset, y + eyeOffset, eyeSize, eyeSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + eyeOffset + 1, y + eyeOffset + 1, pupilSize, pupilSize);

            ctx.fillStyle = '#fff';
            ctx.fillRect(x + eyeOffset, y + eyeOffset + 9, eyeSize, eyeSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + eyeOffset + 1, y + eyeOffset + 10, pupilSize, pupilSize);
          } else if (direction.y === -1) { // Arriba
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + eyeOffset, y + eyeOffset, eyeSize, eyeSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + eyeOffset + 1, y + eyeOffset + 1, pupilSize, pupilSize);

            ctx.fillStyle = '#fff';
            ctx.fillRect(x + eyeOffset + 9, y + eyeOffset, eyeSize, eyeSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + eyeOffset + 10, y + eyeOffset + 1, pupilSize, pupilSize);
          } else { // Abajo
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + eyeOffset, y + eyeOffset + 7, eyeSize, eyeSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + eyeOffset + 1, y + eyeOffset + 8, pupilSize, pupilSize);

            ctx.fillStyle = '#fff';
            ctx.fillRect(x + eyeOffset + 9, y + eyeOffset + 7, eyeSize, eyeSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + eyeOffset + 10, y + eyeOffset + 8, pupilSize, pupilSize);
          }
        } else {
          // Cuerpo con gradiente din√°mico
          const bodyGradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize);
          const progress = index / snake.length;

          if (compressionMode) {
            const red = 255;
            const green = 180 - (index % 5) * 20;
            const blue = green;
            bodyGradient.addColorStop(0, `rgb(${red}, ${green}, ${blue})`);
            bodyGradient.addColorStop(1, `rgb(${red - 30}, ${Math.max(100, green - 30)}, ${Math.max(100, blue - 30)})`);
          } else {
            const green = 230 - (index % 5) * 15;
            bodyGradient.addColorStop(0, `rgb(46, ${green}, 115)`);
            bodyGradient.addColorStop(1, `rgb(32, ${Math.max(150, green - 20)}, 107)`);
          }

          // Sombra del segmento
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(x + 2, y + 2, size - 2, size - 2);

          // Cuerpo con gradiente
          ctx.fillStyle = bodyGradient;
          ctx.fillRect(x + 1, y + 1, size, size);

          // Brillo sutil
          ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
          ctx.fillRect(x + 1, y + 1, size, size / 4);

          // Borde
          ctx.strokeStyle = compressionMode
            ? `rgba(255, ${180 - (index % 5) * 20}, ${180 - (index % 5) * 20}, 0.5)`
            : `rgba(46, ${230 - (index % 5) * 15}, 115, 0.5)`;
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 1, y + 1, size, size);
        }
      });
    }

    function gameLoop () {
      if (!gameRunning || gamePaused) return;

      update();
      draw();

      setTimeout(gameLoop, gameSpeed);
    }

    // Inicializar
    draw();
    updateModeDisplay();
  </script>
</body>

</html>